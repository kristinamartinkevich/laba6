1. Чем класс отличается от структуры? Что может и чего не может быть в структуре?


Классы и структуры являются двумя основными конструкциями системы общих типов CTS, используемой в платформе .NET Framework. Оба они являются структурами данных, которые инкапсулируют набор данных и поведений в одной логической сущности. Данные и поведение являются членами класса или структуры. К ним относятся методы, свойства, события и другие элементы, которые описаны далее в этой статье.
Объявление класса или структуры служит своего рода чертежом для создания экземпляров или объектов во время выполнения. Если вы определите класс или структур с именем Person, то Person здесь обозначает имя типа. Если вы объявите и инициализируете переменную p типа Person, принято говорить, что p является объектом (или экземпляром) Person. Можно создать несколько экземпляров одного типа Person, и каждый экземпляр будет иметь разные значения свойств и полей.
Класс является ссылочным типом. Когда вы создаете объект класса и сохраняете его в переменную, эта переменная содержит только ссылку на память объекта. Если ссылка на объект сохраняется в новую переменную, эта переменная также ссылается на исходный объект. Изменения, внесенные через одну переменную, отражаются и в другой переменной, поскольку обе они ссылаются на одни и те же данные.
Структура (struct) является типом значения. При создании структуры переменная, которой присвоена структура, содержит фактические данные этой структуры. Если структура присваивается новой переменной, все данные копируются. Таким образом, новая переменная и исходная переменная содержат две отдельные копии одинаковых данных. Изменения, внесенные в одну копию, не влияют на другую.
В общем случае классы используются для моделирования более сложного поведения или для таких данных, которые будут изменяться после создания объекта класса. Структуры лучше подходят для небольших структур данных, информация в которых не должна изменяться после создания структуры.



2. Что такое перечисление? Приведите пример определения и использования перечисления


Перечисление (enumeration) — это определяемый пользователем целочисленный тип. Когда вы объявляете перечисление, то специфицируете набор допустимых значений, которые могут принимать экземпляры перечислений. Но мало того — этим значениям еще должны быть присвоены имена, понятные для пользователей. Если где-то в коде попытаться присвоить экземпляру перечисления значение, не входящее в список допустимых, компилятор выдаст ошибку.

Определение перечисления может в долговременной перспективе сэкономить массу времени и избавить от головной боли. Существует, по крайней мере, три явных выгоды от применения перечислений вместо простых целых:

Как упоминалось, перечисления облегчают сопровождение кода, гарантируя, что переменным будут присваиваться только легитимные, ожидаемые значения.

Перечисления делают код яснее, позволяя обращаться к целым значениям, называя их осмысленными именами вместо малопонятных "магических" чисел.

Перечисления облегчают ввод исходного кода. Когда вы собираетесь присвоить значение экземпляру перечислимого типа, то интегрированная среда Visual Studio с помощью средства IntelliSense отображает всплывающий список с допустимыми значениями, что позволяет сэкономить несколько нажатий клавиш и напомнить о возможном выборе значений.

Перечислимый тип данных объявляется с помощью ключевого слова enum. Ниже приведена общая форма объявления перечисления:

enum имя {список_перечисления};
где имя — это имя типа перечисления, а список_перечисления — список идентификаторов, разделяемый запятыми.

Следует особо подчеркнуть, что каждая символически обозначаемая константа в перечислении имеет целое значение. Тем не менее неявные преобразования перечислимого типа во встроенные целочисленные типы и обратно в C# не определены, а значит, в подобных случаях требуется явное приведение типов. Кроме того, приведение типов требуется при преобразовании двух перечислимых типов. Но поскольку перечисления обозначают целые значения, то их можно, например, использовать для управления оператором выбора switch или же оператором цикла for.

Для каждой последующей символически обозначаемой константы в перечислении задается целое значение, которое на единицу больше, чем у предыдущей константы. По умолчанию значение первой символически обозначаемой константы в перечислении равно нулю.

Давайте рассмотрим пример использования перечислений:

using System;

namespace ConsoleApplication1
{
    // Создать перечисление
    enum UI : long { Name, Family, ShortName = 5, Age, Sex }

    class Program
    {
        static void Main()
        {
            UI user1;
            for (user1 = UI.Name; user1 <= UI.Sex; user1++)
                Console.WriteLine("Элемент: \"{0}\", значение {1}",user1,(int)user1);

            Console.ReadLine();
        }
    }
}
Перечисления C#
Значение одной или нескольких символически обозначаемых констант в перечислении можно задать с помощью инициализатора. Для этого достаточно указать после символического обозначения отдельной константы знак равенства и целое значение. Каждой последующей константе присваивается значение, которое на единицу больше значения предыдущей инициализированной константы. В приведенном выше примере инициализируется константа ShortName.

По умолчанию в качестве базового для перечислений выбирается тип int, тем не менее перечисление может быть создано любого целочисленного типа, за исключением char. Для того чтобы указать другой тип, кроме int, достаточно поместить этот тип после имени перечисления, отделив его двоеточием.

Изменять базовый тип перечислений удобно в случае создания таких приложений .NET, которые будут развертываться на устройствах с небольшим объемом памяти (таких как поддерживающие .NET сотовые телефоны или устройства PDA), чтобы экономить память везде, где только возможно. Естественно, если для перечисления в качестве базового типа указан byte, каждое значение в этом перечислении ни в коем случае не должно выходить за рамки диапазона его допустимых значений.

Перечисления очень широко применяются во всех библиотеках базовых классов .NET. Например, в ADO.NET множество перечислений используется для обозначения состояния соединения с базой данных (например, открыто оно или закрыто) и состояния строки в DataTable (например, является она измененной, новой или отсоединенной). Поэтому в случае применения любых перечислений следует всегда помнить о наличии возможности взаимодействовать с парами "имя/значение" в них с помощью членов System.Enum.




3. Перечислите и поясните стандартные интерфейсы .Net?




В библиотеке .NET определено множество стандартных интерфейсов, задающих желаемое поведение объектов. Например, интерфейс IComparable задает метод сравнения объектов по принципу больше или меньше, что позволяет выполнять их сортировку. Реализация интерфейсов IEnumerable и IEnumerator дает возможность просматривать содержимое объекта с помощью конструкции foreach, а реализация интерфейса ICloneable – клонировать объекты.

Стандартные интерфейсы поддерживаются многими стандартными классами библиотеки. Например, работа с массивами с помощью цикла foreach возможна именно потому, что тип Array реализует интерфейсы IEnumerable и IEnumerator. Можно создавать и собственные классы, поддерживающие стандартные интерфейсы, что позволит использовать объекты этих классов стандартными способами.

Сравнение объектов (интерфейс IComparable)

Интерфейс IComparable содержит всего один метод CompareTo(),возвращающий результат сравнения двух объектов – текущего и переданного ему в качеству параметра:

interface IComparable

{

int CompareTo(object obj)

}

Метод должен возвращать:

o 0, если текущий объект и параметр равны

o отрицательное число, если текущий объект меньше параметра

o положительное число, если текущий объект больше параметра

Пример использования стандартного интерфейса IComparable на примере класса Monster

namespace ConsoleApplication1

{

//создание класса, использующего интерфейс для сравнения элементов

class Monster : IComparable

{

public Monster(int сила, int умение, string имя)

{

this.сила = сила;

this.умение = умение;

this.имя = имя;

}

public void Passport()

{

Console.WriteLine("Монстр {0} сила = {1} умение= {2}", имя, сила, умение);

}

//обязательная реализация этого метода, т.к. он находится в интерфейсе

public int CompareTo(object obj)

{

Monster temp = (Monster)obj;

if (this.сила > temp.сила) return 1;

if (this.сила < temp.сила) return -1;

return 0;

}

string имя;

int сила, умение;

}

 

class Program

{

static void Main(string[] args)

{

const int n = 3;

Monster[] mas = new Monster[n]; //массив монстров

//инициализация каждого монстра(элемента массива)

mas[0] = new Monster(50, 50, "Вася");

mas[1] = new Monster(100, 100, "Петя");

mas[2] = new Monster(40, 10, "Игорь");

//Только теперь сортировка массива экземпляров класса Monster стала доступной, //благодаря методу CompareTo()

Array.Sort(mas);

//вывод элементов массива монстров

foreach (Monster x in mas)



x.Passport();

Console.ReadLine(); } } }

В данной программе критерием сортировки является поле сила для каждого монстра. То есть массив сортируется по возрастанию этого поля у всех экземпляров класса Monster.

Если несколько экземпляров имеют одинаковое значение критерия сортировки, то порядок их следования не изменится.

Во многих алгоритмах требуется выполнить сортировку по различным критериям. Для этого используется интерфейс IComparer.

Сортировка объектов по различным критериям (интерфейс IComparer)

Данный интерфейс определен в пространстве имен System.Collections. Он также содержит один методCompare(),возвращающий результат сравнения двух объектов, переданных ему в качестве параметров.

interface IComparer

{

int Compare(object obj1,object obj2)

}

Принцип применения этого интерфейса состоит в том, что для каждого критерия сортировки объектов описывается небольшой вспомогательный класс, реализующий этот интерфейс. Объект этого класса передается в стандартный метод сортировки массива в качестве второго аргумента.

Модернизируем предыдущий пример и отсортируем массив экземпляров класса Monster по двум критериям – по именам (свойство Имя, класс SortByИмя) и умениям (свойство Умение, класс SortByУмение). Классы критериев сортировки объявлены вложенными, так как требуются только экземплярам класса Monster.

Пример использования стандартного интерфейса IComparer на примере класса Monster

using System;

using System.Collections;//обязательное подключение данного пространства имен

using System.Linq;

using System.Text;

namespace ConsoleApplication1

{

class Monster //обратите внимание на то, что класс не поддерживает интерфейс

{

public Monster(int сила, int умение, string имя)

{

this.сила = сила;

this.умение = умение;

this.имя = имя;

}

public int Умение

{

get { return умение; }

set

{

if (value > 0) умение = value;

else умение = 0;

}

}

public string Имя

{

get { return имя; }

}

 

public void Passport()

{

Console.WriteLine("Монстр {0} сила = {1} умение= {2}", имя, сила, умение);

}

//Создание ВЛОЖЕННОГО КЛАССА для сортировки по одному критерию

public class SortByИмя : IComparer

{

//вызов стандартного метода Compare() интерфейса и реализация его для сортировки по //имени

int IComparer.Compare(object obj1, object obj2)

{

Monster m1 = (Monster)obj1;

Monster m2 = (Monster)obj2;

return String.Compare(m1.Имя, m2.Имя);

}

}

//Создание второго ВЛОЖЕННОГО КЛАССА для сортировки по одному критерию

public class SortByУмение : IComparer

{

//вызов стандартного метода Compare() интерфейса и реализация его для сортировки по //умению

int IComparer.Compare(object obj1, object obj2)

{

Monster m1 = (Monster)obj1;

Monster m2 = (Monster)obj2;

if (m1.Умение > m2.Умение) return 1;

if (m1.Умение < m28Умение) return -1;

return 0;

 

}

}

string имя;

int сила, умение;

}

 

class Program

{

static void Main(string[] args)

{

const int n = 3;

Monster[] mas = new Monster[n];

//инициализация каждого монстра(элемента массива)

mas[0] = new Monster(50, 50, "Вася");

mas[1] = new Monster(100, 100, "Петя");

mas[2] = new Monster(40, 10, "Игорь");

Console.WriteLine("Сортировка по имени");

//метод Sort() вызывается с двумя параметрами!!!

//2-ой параметр – экземпляр класса Monster.SortByИмя – это полное имя класса!!!

Array.Sort(mas, new Monster.SortByИмя());

foreach (Monster x in mas)

x.Passport();

Console.WriteLine("Сортировка по умениям");

Array.Sort(mas, new Monster.SortByУмение());

foreach (Monster x in mas)

x.Passport();

Console.ReadLine(); } }}

Клонирование объектов (интерфейс ICloneable)

Клонирование-создание копии объекта. Копия объекта называется клоном. При присваивании одного экземпляра другому копируется ссылка, а не сам объект. Если необходимо скопировать в другую область памяти поля объекта, можно воспользоваться методом MemberwiseClone(), который любой объект наследует от класса object. При этом объекты, на которые указывают поля объекта, в свою очередь являющиеся ссылками, не копируются. Это называется поверхностным клонированием. Для создания полностью независимых объектов необходимо глубокое копирование, когда в памяти создается дубликат всего дерева объектов, то есть объектов, на которые ссылаются поля объекта, поля полей, и т.д. Алгоритм глубокого копирования сложен, требует рекурсивного обхода всех ссылок объекта и отслеживания циклических зависимостей.

Объект, имеющий собственные алгоритмы клонирования, должен объявляться как производный интерфейса ICloneable и переопределять его единственный метод Clone().

Модернизируем предыдущий пример и создадим поверхностную копию экземпляра класса Monster с помощью метода MemberwiseClone() и реализации интерфейса ICloneable. Метод MemberwiseClone() можно вызывать только из методов класса, так как он объявлен в классе object как protected.

using System;

using System.Collections;

using System.Linq;

using System.Text;

namespace ConsoleApplication1

{

class Monster :ICloneable

{

public Monster(int сила, int умение, string имя)

{

this.сила = сила;

this.умение = умение;

this.имя = имя;

}

public Monster ShallowClone()

{

return (Monster)this.MemberwiseClone();

}

public object Clone()

{

return new Monster(this.сила, this.умение, "Это-клон!" + this.имя);

}

public int Умение

{

get { return умение; }

set

{

if (value > 0) умение = value;

else умение = 0;

}

}

public void Passport()

{

Console.WriteLine("Монстр {0} сила = {1} умение= {2}", имя, сила, умение);

}

string имя;

int сила, умение;

}

class Program

{

static void Main(string[] args)

{ Monster Вася=new Monster (100,100,"Вася");

Monster X = Вася;

//2 способа создания клонов – метод ShallowClone() и Clone()

Monster Y = Вася.ShallowClone();

Monster Z = (Monster)Вася.Clone();

Чем отличается

Вася.Passport();

X.Passport();

Y.Passport();

Z.Passport();

Console.ReadLine(); } }}

 

Экземпляр X ссылается на ту же область памяти.ю что и экземпляр Вася. Следовательно, если внести изменения в один из этих объектов, это отразится на другом. Экземпляры Y и Z, созданные путем клонироания, обладают собственными копиями значений полей и независимы от исходного экземпляра.





4. Что такое полиморфизм? Перечислите его формы. Приведите примеры


Полиморфизм является третьим ключевым аспектом объектно-ориентированного программирования и предполагает способность к изменению функционала, унаследованного от базового класса. Полиморфизм предполагает определение полиморфного интерфейса в базовом классе - набор членов класса, которые могут быть переопределены в классе-наследнике. Методы, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором virtual. Такие методы называют виртуальными. Они и представляют полиморфный интерфейс (также частью полиморфного интерфейса могут быть абстрактные члены класса, о которых рассказывается в следующей теме).

При определении класса-наследника и наследовании методов базового класса мы можем выбрать одну из следующих стратегий:

Обычное наследование всех членов базового класса в классе-наследнике

Переопределение членов базового класса в классе-наследнике

Скрытие членов базового класса в классе-наследнике

Первая стратегия довольно проста. Допустим, есть следующая пара классов Person и Employee:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public Person(string lName, string fName)
    {
        FirstName = fName;
        LastName = lName;
    }
     
    public virtual void Display()
    {
        Console.WriteLine(FirstName + " " + LastName);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string lName, string fName, string comp)
            :base(fName, lName)
    {
        Company = comp;
    }
}
В базовом классе Person метод Display() определен с модификаторами virtual, поэтому данный метод может быть переопределен. Но класс Employee наследует его как есть:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person("Bill", "Gates");
        p1.Display(); // вызов метода Display из класса Person
 
        Person p2 = new Employee("Tom", "Johns", "UnitBank");
        p2.Display(); // вызов метода Display из класса Person
 
        Employee p3 = new Employee("Sam", "Toms", "CreditBank");
        p3.Display(); // вызов метода Display из класса Person
        Console.Read();
    }
}
Консольный вывод:

Bill Gates
Tom Johns
Sam Toms
Вторая стратегия - переопределение методов базового класса в классе-наследнике предполагает использование ключевого слова override:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string lName, string fName, string comp)
            :base(fName, lName)
    {
        Company = comp;
    }
     
    public override void Display()
    {
        Console.WriteLine(FirstName + " " + LastName + " работает в компании "+ Company);
    }
}
Класс Person остается тем же, в нем так же метод Display объявляется как виртуальный. В этом случае поведение объекта Employee изменится:

1
2
3
4
5
6
7
8
Person p1 = new Person("Bill", "Gates");
p1.Display(); // вызов метода Display из класса Person
 
Person p2 = new Employee("Tom", "Johns", "UnitBank");
p2.Display(); // вызов метода Display из класса Employee
 
Employee p3 = new Employee("Sam", "Toms", "CreditBank");
p3.Display(); // вызов метода Display из класса Employee
Консольный вывод:

Bill Gates
Tom Johns работает в компании UnitBank
Sam Toms работает в компании CreditBank
При третьей стратегии можно просто определить в классе-наследнике метод с тем же именем, добавив в его определение ключевое слово new:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string lName, string fName, string comp)
            :base(fName, lName)
    {
        Company = comp;
    }
     
    public new void Display()
    {
        Console.WriteLine(FirstName + " " + LastName + " работает в компании "+ Company);
    }
}
В этом случае метод Display() в Employee скрывает метод Display() из класса Person. Чтобы явно скрыть метод из базового класса, используется ключевое слово new, хотя в принципе оно необязательно, по умолчанию система это делает неявно.

Использование в программе:

1
2
3
4
5
6
7
8
Person p1 = new Person("Bill", "Gates");
p1.Display(); // вызов метода Display из класса Person
 
Person p2 = new Employee("Tom", "Johns", "UnitBank");
p2.Display(); // вызов метода Display из класса Person
 
Employee p3 = new Employee("Sam", "Toms", "CreditBank");
p3.Display(); // вызов метода Display из класса Employee
Консольный вывод:

Bill Gates
Tom Johns
Sam Toms работает в компании CreditBank
Обратите внимание на различия во втором случае (p2.Display()) при разных стратегиях.

Ключевое слово base

Кроме конструкторов, мы можем обратиться с помощью ключевого слова base к другим членам базового класса. В нашем случае вызов base.Display(); будет обращением к методу Display() в классе Person:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
class Employee : Person
{
    public string Company { get; set; }
  
    public Employee(string lName, string fName, string comp)
            :base(fName, lName)
    {
        Company = comp;
    }
  
    public override void Display()
    {
        base.Display();
        Console.WriteLine("Место работы : " + Company);
    }
}
Запрет переопределения методов

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором sealed:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
class Employee : Person
{
    public string Company { get; set; }
  
    public Employee(string lName, string fName, string comp)
            :base(fName, lName)
    {
        Company = comp;
    }
  
    public override sealed void Display()
    {
        base.Display();
        Console.WriteLine("Место работы : " + Company);
    }
}
При создании методов с модификатором sealed надо учитывать, что sealed применяется в паре с override, то есть только в переопределяемых методах.

И в этом случае мы не сможем переопределить метод Display в классе, унаследованном от Employee.


