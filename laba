using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;


namespace ConsoleApplication1
{
     //Перечисление(enumeration)
    //— это определяемый пользователем целочисленный тип.
    //Когда вы объявляете перечисление, то специфицируете набор допустимых значений, 
    //которые могут принимать экземпляры перечислений.Но мало того — этим значениям еще должны 
    //быть присвоены имена, понятные для пользователей.Если где-то в коде попытаться присвоить экземпляру
    //перечисления значение, не входящее в список допустимых, компилятор выдаст ошибку.
    //Определение перечисления может в долговременной перспективе сэкономить массу времени и избавить
    //от головной боли. Существует, по крайней мере, три явных выгоды от применения перечислений вместо простых целых:

     //Перечисления облегчают ввод исходного кода.Когда вы собираетесь присвоить значение 
     //экземпляру перечислимого типа, то интегрированная среда Visual Studio с помощью средства 
     //IntelliSense отображает всплывающий список с допустимыми значениями, что позволяет 
      //сэкономить несколько нажатий клавиш и напомнить о возможном выборе значений.
      // Создать перечисление
    enum UI : long { Name, Family, ShortName = 5, Age, Pol }


	//структура

	//Кроме базовых элементарных типов данных и перечислений в C# имеется и 
    //составной тип данных, который называется структурой. Структуры могут содержать в себе обычные переменные и методы.



	struct Book
	{
		public string name;
		public string author;
		public int year;

		public void Info()
		{
			Console.WriteLine("\nКнига '{0}' (автор {1}) была издана в {2} году\n", name, author, year);
		}
	}


    //букет

    class Buket : IComparable<Buket>
    {
        public string FlowerName { set; get; }
        public string Color { get; set; }
        public double Cost { get; set; }
        public byte Discount { get; set; }
        public int ID { get; set; }

        public Buket() { }
        public Buket(string FlowerName, string Color, double Cost, byte Discount, int ID)
        {
            this.FlowerName = FlowerName;
            this.Color = Color;
            this.Cost = Cost;
            this.Discount = Discount;
            this.ID = ID;
        }

        // Реализуем интерфейс IComparable<T>
        public int CompareTo(Buket obj)
        {
            if (this.Cost > obj.Cost)
                return 1;
            if (this.Cost < obj.Cost)
                return -1;
            else
                return 0;
        }


	


		public override string ToString()
        {
            return String.Format("{4}\tНазвание: {0}\tЦвет: {1}\tЦена: {2:C}\tСкидка: {3}%",
                this.FlowerName, this.Color, this.Cost, this.Discount, this.ID);
        }
    }


    class Program
    {
        static void Main()
        {

            //перечесления

            UI user1;
            for (user1 = UI.Name; user1 <= UI.Pol; user1++)
                Console.WriteLine("Элемент: \"{0}\", значение {1}", user1, (int)user1);
            


			//структуры

            Book book;
            book.name = "Война и мир";
            book.author = "Л. Н. Толстой";
            book.year = 1869;
  
            //Выведем информацию о книге book на экран
            book.Info();



			//букет

			//Если требуется отсортировать коллекцию, состоящую из объектов определяемого пользователем класса,
            //при условии, что они не сохраняются в коллекции класса SortedList, где элементы располагаются в
            //отсортированном порядке, то в такой коллекции должен быть известен способ сортировки содержащихся 
            //в ней объектов. С этой целью можно, в частности, реализовать интерфейс IComparable для объектов 
            //сохраняемого типа.Интерфейс IComparable доступен в двух формах: обобщенной и необобщенной.Несмотря 
            //на сходство применения обеих форм данного интерфейса, между ними имеются некоторые, хотя и небольшие, отличия.

            //Если требуется отсортировать объекты, хранящиеся в необобщенной коллекции, то для этой цели придется реализовать 
            //необобщенный вариант интерфейса IComparable. В этом варианте данного интерфейса определяется только один метод,
            //CompareTo(), который определяет порядок выполнения самого сравнения. Ниже приведена общая форма объявления
            //метода CompareTo():

            //int CompareTo(object obj)
            //В методе CompareTo() вызывающий объект сравнивается с объектом obj. Для сортировки объектов по нарастающей 
            //конкретная реализация данного метода должна возвращать нулевое значение, если значения сравниваемых объектов равны;
            //положительное — если значение вызывающего объекта больше, чем у объекта obj; и отрицательное — если значение 
            //вызывающего объекта меньше, чем у объекта obj. А для сортировки по убывающей можно обратить результат сравнения 
            //объектов. Если же тип объекта obj не подходит для сравнения с вызывающим объектом, то в методе CompareTo() может
            //быть сгенерировано исключение ArgumentException.

            //Если требуется отсортировать объекты, хранящиеся в обобщенной коллекции, то для этой цели придется реализовать
            //обобщенный вариант интерфейса IComparable<T>. В этом варианте интерфейса IComparable определяется приведенная 
            //ниже обобщенная форма метода CompareTo():

            //int CompareTo(Т other)
            //В методе CompareTo() вызывающий объект сравнивается с другим объектом other.Для сортировки объектов по 
            //нарастающей конкретная реализация данного метода должна возвращать нулевое значение, если значения
            //сравниваемых объектов равны; положительное — если значение вызывающего объекта больше, чем у объекта другого
            //other; и отрицательное — если значение вызывающего объекта меньше, чем у другого объекта other.А для сортировки по
            //убывающей можно обратить результат сравнения объектов. При реализации обобщенного интерфейса IComparable<T> имя 
            //типа реализующего класса обычно передается в качестве аргумента типа.
			List<Buket> dic = new List<Buket>();

			// Создадим множество цветов
			dic.Add(new Buket("Роза    ", "красный",12, 5, 1));
			dic.Add(new Buket("Тюльпан ", "розовый", 7, 0, 2));
			dic.Add(new Buket("Ромашка ", "белый  ", 3, 15, 3));
			dic.Add(new Buket("Гвоздика", "красный", 1, 3, 4));
			dic.Add(new Buket("Пион    ", "белый  ", 30, 10, 5));

			Console.WriteLine("\tИсходный каталог цветов: \n");
			foreach (Buket a in dic)
				Console.WriteLine(a);

			Console.WriteLine("\nТеперь цветы отсортированны по стоимости: \n");
			dic.Sort();
			foreach (Buket a in dic)
				Console.WriteLine(a);




			// найти заданный цвет
			List<string> Colors = new List<string>();
			Colors.Add("розовый");
			Colors.Add("красный");
			Colors.Add("белый");
			Colors.Add("фиолетовый");
			Colors.Add("желтый");

			int itemPosition = Colors.BinarySearch("красный");
			Console.WriteLine("Цвет найден в позиции: {0}", itemPosition + 1);



			Console.ReadLine();
			
		}
    }
}



//partial 1


//Частичные классы (partial class) представляют возможность разделить 
//функционал одного класса на несколько файлов. Например, сейчас у нас код класса
//весь находится в одном файле. Но мы можем разделить весь код на
//несколько разных файлов. В этом случае нам надо будет поставить перед определением класса ключевое слово partial. 


namespace PC
{
	partial class A
	{
		int num = 0;
		void MethodA() { }
		partial void MethodC();
	}
}


//partial 2

namespace PC
{
	partial class A
	{
		void MethodB() { }
		partial void MethodC() { }
	}
}
